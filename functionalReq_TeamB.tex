\subsection{Functional Requirements Review}
%Tienie
\subsubsection{Threads.getThreadStats}

\begin{itemize}
	\item Parameters
		\begin{itemize}
			\item A set of posts returned by the Threads.queryThread function.
			\begin{itemize}
				\item \color{green}
\textbf{\small \emph{Passed}} \\
				\color{black} \item The Parameter Exists
			\end{itemize}
			\item Action Keyword 
			\begin{itemize}
				\item Num
				\begin{itemize}
					\item \color{green}
\textbf{\small \emph{Passed}} \\\color{black}
					\item Successfully retrieves count of entries
				\end{itemize}
				\item MemCount
				\begin{itemize}
					\item \color{green}
\textbf{\small \emph{Passed}} \\ \color{black}
					\item Successfully retrieves count of entries
				\end{itemize}
				\item MaxDepth
				\begin{itemize}
					\item \color{red}
\textbf{\small \emph{Failed}} \\\color{black}
					\item This function counts unique occurrences of parent IDs – it does not count the depth. Assumptions about the amount of unique parent IDs do not relate to the depth of the tree. For example, all threads on level 2 could have children, which will cause the children on level 3 to have unique parent ID’s for every thread on level 2, but that amount of unique parent IDs do not relate to the level, as level 2 could have thousands of threads.
					\item Currently, this function will return the largest amount of threads on a level, NOT the depth of the tree.
				\end{itemize}
				\item AvgDepth
				\begin{itemize}
					\item \color{red}
\textbf{\small \emph{Failed}} \\\color{black}
					\item The code used for this function is almost exactly the same as that of MaxDepth, and MaxDepth does not count the depth, thus AvgDepth will fail.
				\end{itemize}
			\end{itemize}
		\end{itemize}
\end{itemize}


\subsubsection{Get Thread Appraisal}
\begin{itemize}
	\item Parameters
	\begin{itemize}
		\item A set of posts returned by Threads.queryThread function
			\begin{itemize}
				\item \color{green}\textbf{\small \emph{Passed}} \\\color{black}
			\end{itemize}
		\item A set of members
			\begin{itemize}
				\item \color{green}
\textbf{\small \emph{Passed}} \\\color{black}
			\end{itemize}
		\item A set of appraisals
			\begin{itemize}
				\item \color{green}
\textbf{\small \emph{Passed}} \\
			\end{itemize}
		\item Action Keyword
			\begin{itemize}
				\item All
					\begin{itemize}
						\item \color{green}
\textbf{\small \emph{Passed}} \\\color{black}
					\end{itemize}
				\item Sum
					\begin{itemize}
						\item \color{green}
\textbf{\small \emph{Passed}} \\\color{black}
					\end{itemize}
				\item Avg
					\begin{itemize}
						\item \color{green}
\textbf{\small \emph{Passed}} \\\color{black}
					\end{itemize}
				\item Max
					\begin{itemize}
						\item \color{green}
\textbf{\small \emph{Passed}} \\\color{black}
					\end{itemize}
				\item Min
					\begin{itemize}
						\item \color{myOrange}
\textbf{\small \emph{Partial Passed}} \\\color{black}
						\item Assuming there is no appraisal value smaller than the assigned min value (100000)
						\item  \color{red}
\textbf{\small \emph{Failed}} \\\color{black}
						\item Because assumptions are made about the appraisal value – the code does not cater for a situation where there is no appraisal value smaller than the min constant (bad code design) 
					\end{itemize}
				\item Num
					\begin{itemize}
						\item \color{red}
\textbf{\small \emph{Failed}} \\\color{black}
						\item Because in JavaScript, null is compared as ‘null’ and not ‘0’ (this isn’t C++). Thus, no empty appraisals will ever be found, and then all records will be found as “non-empty”. Or, it will simply count all the appraisals whose value aren’t “0”.
					\end{itemize}
			\end{itemize}
	\end{itemize}
\end{itemize}


\subsection{Export Thread Appraisal}
\begin{itemize}
	\item An external file is created 
	\begin{itemize}
		\item \color{green}\textbf{\small \emph{Passed}}
	\end{itemize}
	\item Containing data generated by the getThreadAppraisal function  
	\begin{itemize}
		\item \color{green}
\textbf{\small \emph{Passed}} \\\color{black}
		\item This data is passed as an argument (parameter threadObject)
	\end{itemize}
	\item Only if the function executed with the All action keyword.
	\begin{itemize}
		\item \color{red}
\textbf{\small \emph{Failed}} \\ \color{black}
		\item This is never tested for, because they assume that the data is passed as an argument – since it’s passed as an argument you will never be able to test if getThreadAppraisal is called with the All action keyword
	\end{itemize}
\end{itemize}


%Vivian
\subsubsection{Import Thread Appraisal}

\paragraph{\color{black} \\ Data in an external file that was created using the exportThreadAppraisal function is used.\\} 
\color{myOrange}
\textbf{\small \emph{Partial Passed}} \\
\color{black}The function do make use of a file. The file is sent as arguments in the importThreadAppraisal function (parameters are directory and  fileName). So in this function they assume this is the file created by the exportThreadAppraisal function.
\par

\paragraph{\color{black} The data set is associated with only one member and only one specified appraisal.\\}
\color{red}
\textbf{\small \emph{Failed}} \\
\color{black} The function never actually check if the data set is about only one member and only one specific appraisal. Therefore the data cannot be deemed as eligible for import.
\par

\paragraph{\color{black}A record contains all detail about the post along with a field that should contain an ordinal number that represents the levels of the specified appraisal.\\}
\color{green}
\textbf{\small \emph{Passed}} \\
\color{black}The record does contain all detail about the post and a field that represents the leves of the specified appraisal which is the appraisalValue.
\par

\paragraph{\color{black} Edits to the data is ignored when importing a thread appraisal.\\}
\color{red}
\textbf{\small \emph{Failed}} \\
\color{black} The function does not prevent edits to the data and there is not clear indicated of ignoring such edits.
\par

\paragraph{\color{black}For each record the assignAppraisalToPost function is applied.\\}
\color{green}
\textbf{\small \small \emph{Passed}} \\
\color{black}The function does call assignAppraisalToPost for each record.
\par

\paragraph{\color{black}The appraisal level as stored in the file for each post is updated as an appraisal assigned by the member associated with the data set.\\}
\color{red}
\textbf{\small \emph{Failed}} \\
\color{black}The function does not use the appraisal level to update the data set.
\par

\paragraph{\color{black}Check validity of member and appraisal.\\}
\color{myOrange}
\textbf{\small \emph{Partial Passed}} \\
\color{black}The function does check the validity of the member, however they have a dummy function that only returns true.\\
The function does check the validity of the appraisal, however no exception is thrown/raised it only returns true or false and there is also no means of catching an exception, that is the isValid function is not surrounded with try/catch blocks to catch exceptions and therefore the service delivery is not stopped when the appraisal is not valid.\\
The appraisal level is check for out of range, however no exception is thrown/raised when is it out of range and there the service delivery is not stopped if the appraisal level is out of range.
\par

\paragraph{\color{black} Full use case test rating\\}
\color{myOrange}
\textbf{\small \emph{Partial Passed}} \\
\color{black}
There were 7 requirements listed for this use case. 
\begin{itemize}
	\item{2 out of 7 passed.} 
	\item{2 out of 7 partially passed.}
	\item{3 out of 7 failed.}
\end{itemize}
Hence, it is save to say the use case only partially passed due to the fact that most requirements was implemented, but there were a lot of requirements missing as well.
\par

\subsubsection{Export Thread }
\paragraph{\color{black}\\An external file is created.\\}
\color{myOrange}
\textbf{\small \emph{Partial Passed}} \\
\color{black}The function does create an external file, however :
	\begin{itemize}
	\item{The data generated to by the queryThread function is assumed to be given as an argument to the function  (parameter threadObject).}
	\item{The data is actually not correctly stored in the file since the threadObject is not parsed as a JSON-string. The object is directly stored in the file. So the actual data of the threadObject is not stored in the file.}
	\end{itemize}
\par

\paragraph{\color{black} Full use case test rating\\}
\color{red}
\textbf{\small \emph{Failed}} \\
\color{black}
This use case failed, since the contents of the file is not what is expected at all. (See point 2 above).
\par

\subsubsection{Import Thread}
\paragraph{\color{black}\\An external file that was created by the exportThread function is used to restore the content of a thread.\\}
\color{green}
\textbf{\small \emph{Passed}} \\
\color{black}The function does use an external file. Again the file is passed as arguments to the function (parameters directory and fileName), so they are assuming this file was generated by the exportThread function before importThread is called with the file as arguments.
\par

\paragraph{\color{black}The content of the external file is used to restore content of a thread/post.\\}
\color{red}
\textbf{\small \emph{Failed}} \\
\color{black}The function never tries to restore or even store the content of the external file on the Buzz Space.
\par

\paragraph{\color{black}A post is added if and only if it is not in the Buzz Space already.\\}
\color{red}
\textbf{\small \emph{Failed}} \\
\color{black}The function never adds the content to the Buzz Space and therefore does not check if it is already in the Buzz Space. 
\par

\paragraph{\color{black} Full use case test rating\\}
\color{red}
\textbf{\small \emph{Failed}} \\
\color{black}
There were 3 requirements listed for this use case. 
\begin{itemize}
	\item{1 out of 3 passed.} 
	\item{2 out of 3 failed.}
\end{itemize}
This use case failed, since a thread was not restored or added to the Buzz Space which was the core functionality of this use case.
\par